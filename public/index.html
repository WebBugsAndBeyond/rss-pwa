<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>PWA RSS Reader</title>
        <style>
            :root {
                --add-button-size: 32px;
            }
            body {
                font-family: 'Courier New', Courier, monospace;
            }
            .app-shell__header,
            .app-shell__footer {
                display: flex;
                position: fixed;
                left: 0;
                right: 0;
                height: 40px;
                width: 100vw;
                background-color: crimson;
            }
            .app-shell__header {
                top: 0;
                bottom: 40px;
                display: flex;
                flex-direction: row;
            }
            .app-shell__header > div > h1 {
                margin: 0;
                padding: 0;
                position: relative;
                left: calc(var(--add-button-size) / 2);
            }
            .app-shell__header > div {
                display: flex;
            }
            .app-shell__header > div:first-of-type {
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-basis: calc(100% - 24px);
            }
            .app-shell__header > div:last-of-type {
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-basis: var(--add-button-size);
            }
            .app-shell__header > div:last-of-type > button {
                font-size: var(--add-button-size);
                line-height: var(--add-button-size);
                width: var(--add-button-size);
                height: var(--add-button-size);
                margin: 0;
                padding: 0;
                color: white;
                background-color: transparent;
                border: none;
            }
            .app-shell__header__site-title,
            .app-shell__footer__copyright {
                font-size: 24px;
                line-height: 30px;
                color: white;
            }
            .app-shell__footer__copyright {
                font-size: 16px;
            }
            .app-shell__footer {
                flex-direction: column;
                justify-content: center;
                align-items: center;
                top: calc(100vh - 40px);
                bottom: 100vh;
            }
            main {
                position: fixed;
                top: 40px;
                left: 0;
                right: 100vw;
                bottom: calc(100vh - 40px);
                width: 100vw;
                height: calc(100vh - 40px - 40px);
                overflow-y: scroll;
            }
            .main-content__feed-accordion-wrapper {
                position: relative;
            }
            rss-feed-item-accordion::part(header) {
                background-color: mintcream;
            }
        </style>
    </head>
    <body>
        <header class="app-shell__header">
            <div>
                <h1 class="app-shell__header__site-title">PWA RSS Feed</h1>
            </div>
            <div>
                <button id="add-feed-url-dialog-open-button">+</button>
            </div>
        </header>
        <main>
            <div class="main-content__feed-accordion-wrapper"></div>
        </main>
        <footer class="app-shell__footer">
            <div class="app-shell__footer__copyright">
                Copyright 2025, WebBugsAndBeyond.
            </div>
        </footer>
        <template id="rss-item-accordion-template">
            <style>
                :host {
                    font-family: 'Courier New', Courier, monospace;
                    font-size: 16px;
                }
                article {
                    display: flex;
                    flex-flow: column nowrap;
                    width: 100%;
                    border-bottom: black solid 1px;
                }
                article > h1 {
                    font-size: 18px;
                    line-height: 24px;
                    height: 30px;
                    display: inline-flex;
                    justify-content: center;
                    margin: 0;
                }
                article > h1 > button {
                    font-family: 'Courier New', Courier, monospace;
                    font-size: 18px;
                    line-height: 24px;
                    border: none;
                    width: 100%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    background: transparent;
                    text-align: left;
                }
                article > div {
                    display: grid;
                    opacity: 0;
                    grid-template-rows: 0fr;
                    transition-property: all;
                    transition-duration: 0.5s;
                    transition-timing-function: ease;
                }
                article > div > div {
                    overflow: hidden;
                }
                article > div.expanded {
                    grid-template-rows: 1fr;
                    opacity: 1;
                    padding: 10px;
                }
                article > div > div {
                    display: block;
                }
                article > div > .creator {
                    font-size: 18px;
                }
                article > div > .pub-date {
                    font-size: 18px;
                }
                article > div > .category {
                    font-size: 16px;
                }
                article > div > .link {
                    font-size: 16px;
                }
                article > div .description {
                    font-size: 12px;
                }
            </style>
            <article>
                <h1 part="header"><button class="title"><slot name="title"></slot></button></h1>
                <div part="content">
                    <div>
                        <div class="creator"><slot name="creator"></slot></div>
                        <div class="pub-date"><slot name="pubDate"></slot></div>
                        <div class="category"><slot name="category"></slot></div>
                        <div class="link"><slot name="link"></slot></div>
                        <div class="description"><slot name="description"></slot></div>
                    </div>
                </div>
            </article>
        </template>
        <template id="rss-channel-template">
            <style>
                :host {
                    font-family: 'Courier New', Courier, monospace;
                }
                h1 {
                    padding-left: 10px;
                    padding-right: 10px;
                    font-size: 16px;
                    font-weight: bold;
                }
                h2 {
                    padding-left: 10px;
                    padding-right: 10px;
                    font-size: 14px;
                    font-weight: normal;
                }
            </style>
            <section>
                <header>
                    <h1><slot name="title"></slot></h1>
                    <h2><slot name="description"></slot></h2>
                </header>
                <div><slot name="items"></slot></div>
            </section>
        </template>
        <template id="user-input-dialog-template">
            <style>
                :host {
                    width: 100vw;
                    height: 100vh;
                    box-sizing: border-box;
                    padding: 0;
                    margin: 0;
                }
                dialog {
                    position: fixed;
                    left: 0;
                    top: 0;
                    width: 100vw;
                    height: 100vh;
                    padding: 0;
                    margin: 0;
                    opacity: 0;
                    z-index: 2;
                    transition-property: opacity;
                    transition-duration: .5s;
                    transition-timing-function: ease-in;
                    background-color: darkblue;
                    display: flex;
                    flex-direction: column;
                    justify-content: space-between;
                    align-items: flex-start;
                    box-sizing: border-box;
                }
                dialog.visible {
                    opacity: 1;
                }
                header {
                    flex-basis: 10%;
                    box-sizing: border-box;
                    width: 100%;
                    padding-left: 10px;
                }
                section.fields {
                    flex-basis: 80%;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    box-sizing: border-box;
                    width: 100%;
                }
                section.controls {
                    flex-basis: 10%;
                    box-sizing: border-box;
                    width: 100%;
                    display: flex;
                }
            </style>
            <dialog>
                <header>
                    <slot name="header"></slot>
                </header>
                <section class="fields">
                    <slot name="input-fields"></slot>
                </section>
                <section class="controls">
                    <slot name="controls"></slot>
                </section>
            </dialog>
        </template>
        <template id="add-feed-url-dialog-template">
            <style>
                h1 {
                    color: white;
                    font-size: 36px;
                }
                .user-input-dialog__input-fields {
                    display: flex;
                    flex-direction: column;
                    justify-content: space-around;
                    align-items: start;
                    padding: 10px;
                    width: 100%;
                    box-sizing: border-box;

                }
                .user-input-dialog__input-fields > label {
                    width: 100%;
                    font-size: 20px;
                    color: white;
                    box-sizing: border-box;
                }
                .user-input-dialog__input-fields > input {
                    width: 100%;
                    font-size: 24px;
                    border-radius: 4px;
                    box-sizing: border-box;
                    height: 40px;
                    border-style: solid;
                    border-width: 1px;
                    border-color: black;
                }
                .user-input-dialog__input-fields > input:focus {
                    border-color: chartreuse;
                }
                div[slot="controls"] {
                    display: flex;
                    flex-direction: row;
                    flex: 1;
                }
                button {
                    flex-basis: 50%;
                    font-weight: bold;
                    font-family: inherit;
                    margin: 0;
                    border: 0;
                    font-size: 24px;
                    line-height: 36px;
                    padding: 0;
                }
                .dialog-button__ok {
                    background-color: yellow;
                    color: red;
                }
                .dialog-button__ok:disabled {
                    background-color:blanchedalmond;
                    color:azure;
                }
                .dialog-button__cancel {
                    background-color: brown;
                    color: antiquewhite;
                }
            </style>
            <user-input-dialog>
                <h1 slot="header">Add Feed URL</h1>
                <div slot="input-fields" class="user-input-dialog__input-fields">
                    <label for="">Feed URL</label>
                    <input 
                        type="url"
                        required
                        id="feed-url-input-field"
                        name="feedUrlInputField"
                        maxlength="255"
                        placeholder="Enter feed URL"
                    >
                </div>
                <div slot="controls">
                    <button class="dialog-button dialog-button__ok" disabled>Add</button>
                    <button class="dialog-button dialog-button__cancel">Cancel</button>
                </div>
            </user-input-dialog>
        </template>
        <script type="module">

            class RSSFeedItem {

                static #textNodeName = '#text';
                static #cdataSectionName = '#cdata-section';
                static #isInternalConstructing = false;

                #titleText = '';
                #linkText = '';
                #creatorCdata = '';
                #pubDateText = '';
                #categoryCdata = '';
                #guidText = '';
                #guidTextIsPermaLink = '';
                #descriptionText = '';
                #contentText = '';
                #postIdText = '';

                constructor(itemElement) {
                    const childElements = Array.from(itemElement.children);
                    for (const element of childElements) {
                        this.#parseItemChildElement(element);
                    }
                }

                get title() {
                    return this.#titleText;
                }
                get link() {
                    return this.#linkText;
                }
                get creator() {
                    return this.#creatorCdata;
                }
                get pubDate() {
                    return this.#pubDateText;
                }
                get category() {
                    return this.#categoryCdata;
                }
                get guid() {
                    return {
                        isPermaLink: this.#guidTextIsPermaLink,
                        text: this.#guidText,
                    };
                }
                get description() {
                    return this.#descriptionText;
                }
                get content() {
                    return this.#contentText;
                }
                get postId() {
                    return this.#postIdText;
                }

                #findNode(rootNode, nodeName) {
                    if (!rootNode) {
                        return null;
                    }
                    if (rootNode.nodeName === nodeName) {
                        return rootNode;
                    }
                    const { childNodes } = rootNode;
                    for (const node of childNodes) {
                        const foundNode = this.#findNode(node, nodeName);
                        if (foundNode) {
                            return foundNode;
                        }
                    }
                    return null;
                }
                
                #parseItemChildElement(element) {
                    const { tagName } = element;
                    switch (tagName) {
                        case 'title':
                            this.#titleText = this.#findNode(
                                element,
                                RSSFeedItem.#textNodeName,
                            )?.nodeValue ?? '';
                            break;
                        case 'link':
                            this.#linkText = this.#findNode(
                                element,
                                RSSFeedItem.#textNodeName,
                            )?.nodeValue ?? '';
                            break;
                        case 'dc:creator':
                            this.#creatorCdata = this.#findNode(
                                element,
                                RSSFeedItem.#cdataSectionName,
                            )?.nodeValue ?? '';
                            break;
                        case 'pubDate':
                            this.#pubDateText = this.#findNode(
                                element,
                                RSSFeedItem.#textNodeName,
                            )?.nodeValue ?? '';
                            break;
                        case 'category':
                            ((nodeValue) => {
                                if (this.#categoryCdata !== '') {
                                    this.#categoryCdata += ',' + nodeValue;
                                } else {
                                    this.#categoryCdata = nodeValue;
                                }
                            })(this.#findNode(
                                element,
                                RSSFeedItem.#cdataSectionName,
                            )?.nodeValue ?? '');
                            break;
                        case 'guid':
                            this.#guidTextIsPermaLink = element.getAttribute('isPermaLink');
                            this.#guidText = this.#findNode(
                                element,
                                RSSFeedItem.#textNodeName,
                            )?.nodeValue ?? '';
                            break;
                        case 'description':
                            this.#descriptionText = this.#findNode(
                                element,
                                RSSFeedItem.#cdataSectionName,
                            )?.nodeValue ?? '';
                            break;
                        case 'content:encoded':
                            this.#contentText = this.#findNode(
                                element,
                                RSSFeedItem.#cdataSectionName,
                            )?.nodeValue ?? '';
                            break;
                        case 'post-id':
                            this.#postIdText = this.#findNode(
                                element,
                                RSSFeedItem.#textNodeName,
                            )?.nodeValue ?? '';
                            break;
                    }
                }
            }

            class RSSFeedChannel {

                #titleText = '';
                #descriptionText = '';
                #lastBuildDateText = '';
                #feedUrlText = '';
                #feedItems = [];
                #updateFrequencyText = '';
                #updatePeriodText = '';
                #updateBaseText = '';

                constructor(feedUrl, xmlText) {
                    this.#feedUrlText = feedUrl;

                    const domParser = new DOMParser();
                    const xmlDocument = domParser.parseFromString(xmlText, 'application/xml');
                    const rssElement = xmlDocument.documentElement;
                    const channelTitleElement = rssElement.querySelector('channel > title');
                    const channelLastBuildElement = rssElement.querySelector('channel > lastBuildDate');
                    const channelDescriptionElement = rssElement.querySelector('channel > description');
                    const itemNodes = rssElement.querySelectorAll('channel > item');
                    const feedItems = Array.from(itemNodes).map(RSSFeedChannel.#parseRSSItem);
                    this.#titleText = channelTitleElement?.textContent ?? '';
                    this.#descriptionText = channelDescriptionElement?.textContent ?? '';
                    this.#feedItems = feedItems;

                }

                static #parseRSSItem(itemNode) {
                    const rssFeedItem = new RSSFeedItem(itemNode);
                    return rssFeedItem;
                }

                get title() {
                    return this.#titleText;
                }

                get description() {
                    return this.#descriptionText;
                }

                get lastBuildDate() {
                    return this.#lastBuildDateText;
                }

                get updateBase() {
                    return this.#updateBaseText;
                }

                get feedUrl() {
                    return this.#feedUrlText;
                }

                get items() {
                    return this.#feedItems;
                }

                get updatePeriod() {
                    return this.#updatePeriodText;
                }

                get updateFrequency() {
                    return this.#updateFrequencyText;
                }

                getSerializableObject() {
                    const value = {
                        title: this.title,
                        feedUrl: this.feedUrl,
                        lastBuildDate: this.lastBuildDate || this.updateBase,
                        updatePeriod: this.updatePeriod,
                        updateFrequency: this.updateFrequency,
                        nextUpdateDate: this.nextUpdateDate,
                    };
                    return value;
                }

                get nextUpdateDate() {
                    if (!this.lastBuildDate || !this.updateBase) {
                        return new Date();
                    }
                    const buildDate = this.lastBuildDate ? new Date(this.lastBuildDate) : new Date(this.updateBase);
                    const daysInMonth = {
                        0: 31,
                        1: (buildDate.getFullYear() % 4 ? 29 : 28),
                        2: 31,
                        3: 30,
                        4: 31,
                        5: 31,
                        6: 30,
                        7: 31,
                        8: 30,
                        9: 31,
                        10: 30,
                        11: 31,
                    };
                    const updatePeriods = ['hourly', 'daily', 'weekly', 'monthly', 'yearly'];
                    const updatePeriodMilliseconds = {
                        hourly: 1000 * 60 * 60,
                        daily: 1000 * 60 * 60 * 24,
                        weekly: 1000 * 60 * 60 * 24 * 7,
                        monthly: 1000 * 60 * 60 * 24 * daysInMonth[buildDate.getMonth()],
                        yearly: 1000 * 60 * 60 * 24 * (buildDate.getFullYear() % 4 ? 366 : 365),
                    };
                    const buildTimeMilliseconds = buildDate.getTime();
                    const nextPeriodMillisecondsOffset = updatePeriodMilliseconds[this.updatePeriod];
                    const nextPeriodMillisecondsTimesFrequency = nextPeriodMillisecondsOffset * Number(this.updateFrequency);
                    const nextUpdateTimeMilliseconds = buildTimeMilliseconds + nextPeriodMillisecondsTimesFrequency;
                    const nextUpdateDate = new Date(nextUpdateTimeMilliseconds);
                    return nextUpdateDate;
                }

                get isNextUpdateReady() {
                    const updateDate = this.nextUpdateDate();
                    const currentDate = Date.now();
                    const differenceInMilliseconds = currentDate - updateDate.getTime();
                    const updateIsInThePastOrNow = differenceInMilliseconds >= 0;
                    return updateIsInThePastOrNow;
                }
            }

            function renderRSSAccordionItem(item) {
                const accordionElement = document.createElement('rss-feed-item-accordion');
                accordionElement.setAttribute('slot', 'items');
                const titleElement = document.createElement('span');
                titleElement.setAttribute('slot', 'title');
                titleElement.textContent = item.title;
                accordionElement.appendChild(titleElement);

                const createdElement = document.createElement('span');
                createdElement.setAttribute('slot', 'creator');
                createdElement.textContent = item.creator;
                accordionElement.appendChild(createdElement);

                const pubDateElement = document.createElement('span');
                pubDateElement.setAttribute('slot', 'pubDate');
                pubDateElement.textContent = item.pubDate;
                accordionElement.appendChild(pubDateElement);
                
                const categoryElement = document.createElement('span');
                categoryElement.setAttribute('slot', 'category');
                if (item.category) {
                    if (Array.isArray(item.category)) {
                        categoryElement.innerHTML = item.category.join(' ');
                    } else {
                        categoryElement.textContent = item.category;
                    }
                }
                accordionElement.appendChild(categoryElement);

                const linkElement = document.createElement('a');
                linkElement.setAttribute('slot', 'link');
                linkElement.setAttribute('href', item.link);
                linkElement.setAttribute('target', '_blank');
                linkElement.textContent = item.link;
                accordionElement.appendChild(linkElement);

                const descriptionElement = document.createElement('div');
                descriptionElement.setAttribute('slot', 'description');
                descriptionElement.innerHTML = item.description;
                accordionElement.appendChild(descriptionElement);
                
                return accordionElement;
            }

            function renderRSSAccordion(items, parent) {
                const renderedItems = items.map(renderRSSAccordionItem);
                const accordionWrapper = document.querySelector(".main-content__feed-accordion-wrapper");
                if (accordionWrapper) {
                    accordionWrapper.append(...renderedItems);
                }
            }

            class LocalStorageStateManager {
                
                /**
                 * Return a deserialized object from local storage.
                 * @param {string} id Storage item key.
                 * @returns {object}
                 * @throws {ReferenceError} A ReferenceError is thrown if window.localStorage is not defined.
                 */
                loadObject(id) {
                    if (window.localStorage) {
                        const serializedObject = window.localStorage.getItem(id);
                        const parsedObject = JSON.parse(serializedObject);
                        return parsedObject;
                    }
                    throw new ReferenceError('Local storage is not supported.');
                }

                /**
                 * Serializes an object to local storage with a given identifier.
                 * @param {string} id Storage item key.
                 * @param {object} dataObject Object to store in local storage as a JSON string.
                 * @returns {undefined}
                 * @throws {ReferenceError} A ReferenceError is thrown if window.localStorage is not supported.
                 */
                storeObject(id, dataObject) {
                    if (window.localStorage) {
                        const serializedObject = JSON.stringify(dataObject);
                        window.localStorage.setItem(id, serializedObject);
                        return;
                    }
                    throw new ReferenceError('Local storage is not supported');
                }
            }

            class Application {
                static #privateInitialization = false;
                static #configuredStorageManager = LocalStorageStateManager;
                static #appStateStorageKey = 'appState';
                static #instance = null;

                #stateManager = null;
                #channels = [];

                constructor(stateManagerImpl) {
                    if (!Application.#privateInitialization) {
                        throw new Error('Direct public instantiation of Application singleton is forbidden');
                    }
                    Application.#privateInitialization = false;
                    this.#stateManager = stateManagerImpl;
                    this.onShowAddURLDialogButtonClick = this.onShowAddURLDialogButtonClick.bind(this);
                }

                static configureStorageManager(storageManagerImpl) {
                    const isFunction = typeof storageManagerImpl === 'function';
                    const hasLoadObjectFunction = typeof storageManagerImpl?.prototype?.loadObject === 'function';
                    const hasStoreObjectFunction = typeof storageManagerImpl?.prototype?.storeObject === 'function';
                    if (isFunction && hasLoadObjectFunction && hasStoreObjectFunction) {
                        this.#configuredStorageManager = storageManagerImpl;
                    }
                }

                static getInstance() {
                    if (this.#instance) {
                        return this.#instance;
                    }
                    this.#privateInitialization = true;
                    const storageManagerImpl = new this.#configuredStorageManager();
                    this.#instance = new Application(storageManagerImpl);
                    return this.#instance;
                }

                /**
                 * Load the last serialized application state using the configured state manager.
                 * @returns {Application}
                 * @throws
                 */ 
                loadApplicationState() {
                    const appState = this.#stateManager.loadObject(Application.#appStateStorageKey);
                    if (Array.isArray(appState?.channels)) {
                        this.#channels = [...appState.channels];
                    }
                    return this;
                }

                /**
                 * Serializes the current state using the configured state manager.
                 * @returns {Application}
                 * @throws
                 */
                storeApplicationState() {
                    const serializableState = {
                        channels: this.#channels.filter(
                            channel => channel instanceof RSSFeedChannel
                        ).map(
                            channel => channel.getSerializableObject()
                        ),
                    };
                    this.#stateManager.storeObject(
                        Application.#appStateStorageKey,
                        serializableState,
                    );
                    return this;
                }

                /**
                 * Determines whether or not the user input dialog for adding RSS feed URLs exists in the DOM.
                 * @returns {boolean}
                 */ 
                doesAddFeedURLDialogExist() {
                    const dialogElementName = 'add-feed-url-dialog';
                    return !!document.querySelector(dialogElementName);
                }

                /**
                 * Add the user input dialog for adding RSS feed URLs into the DOM.
                 * @returns {AddFeedURLDialogElement}
                 */
                addAddFeedURLDialog() {
                    const dialogElementName = 'add-feed-url-dialog';
                    let dialogElement = document.querySelector(dialogElementName);
                    if (dialogElement) {
                        return dialogElement;
                    }
                    dialogElement = document.createElement(dialogElementName);
                    document.body.appendChild(dialogElement);
                    return dialogElement;
                }

                /**
                 * Removes the user input dialog for adding RSS feed URLs from the DOM.
                 */ 
                removeAddFeedURLDialog() {
                    const dialogElementName = 'add-feed-url-dialog';
                    const dialogElement = document.body.querySelector(dialogElementName);
                    if (dialogElement) {
                        document.body.removeChild(dialogElement);
                    }
                }

                /**
                 * Shows the user input dialog for adding RSS feed URLs ensuring that it is in the DOM first.
                 * Returns a Promise that is resolved with a reference to the custom element instance
                 * when the visual style transition completes.
                 * @returns {Promise<AddFeedURLDialogElement>}
                 */ 
                showAddFeedURLDialog() {
                    const dialogElement = this.addAddFeedURLDialog();
                    return dialogElement.show();
                }

                /**
                 * Hides and removes the user input dialog for adding RSS feed URLs.
                 * @returns {Application}
                 */ 
                hideAddFeedURLDialog() {
                    const dialogElementName = 'add-feed-url-dialog';
                    const dialogElement = document.body.querySelector(dialogElementName);
                    if (dialogElement) {
                        dialogElement.hide().finally(() => {
                            this.removeAddFeedURLDialog();
                            this.handleShowAddURLDialogButtonClick();
                        });
                    }
                    return this;
                }

                /**
                 * Show the user input dialog for adding RSS feed URLs if it does not already exist.
                 */ 
                onShowAddURLDialogButtonClick() {
                    if (!this.doesAddFeedURLDialogExist()) {
                        this.showAddFeedURLDialog();
                    }
                }

                /**
                 * Adds the click event handler to the button that shows the user input dialog
                 * for adding RSS feed URLs.
                 * @returns {Application}
                 */ 
                handleShowAddURLDialogButtonClick() {
                    const addUrlButtonId = 'add-feed-url-dialog-open-button';
                    const addUrlButton = document.getElementById(addUrlButtonId);
                    if (addUrlButton) {
                        addUrlButton.addEventListener('click', this.onShowAddURLDialogButtonClick, {
                            once: true,
                        });
                    }
                    return this;
                }
            
                /**
                 * Adds a new RSS feed subscription.
                 * @param {string} feedUrl
                 * @returns {Application}
                 */ 
                addRSSFeedUrlSubscription(feedUrl) {
                    if (!isValidUrl(feedUrl)) {
                        return this;
                    }
                    const channelElement = document.createElement('rss-feed-channel');
                    channelElement.setAttribute('feed-url', feedUrl);
                    const accordionWrapper = document.querySelector('.main-content__feed-accordion-wrapper');
                    if (accordionWrapper) {
                        accordionWrapper.appendChild(channelElement);
                    }
                    return this;
                }

                /**
                 * @param {string} feedUrl
                 * @returns {string}
                 */
                requestFeedXMLDocument(feedUrl) {
                    const url = `http://localhost:8080/feed?feed=${encodeURIComponent(feedUrl)}`;
                    return fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/xml',
                        },
                    }).then(
                        response => response.text()
                    ).catch((error) => {
                        const { message } = error;
                        console.log(message);
                    });
                }

                loadRSSFeed(feedUrl) {
                    return this.requestFeedXMLDocument(feedUrl).then(xmlText => {
                        const channel = new RSSFeedChannel(feedUrl, xmlText);
                        // const renderedItems = channel.items.map(renderRSSAccordionItem);
                        this.#channels.push(channel);
                        this.storeApplicationState();
                        return channel;
                    });
                }
            }

            function isValidUrl(urlInput) {
                try {
                    const parsedUrl = new URL(urlInput);
                    if (parsedUrl.protocol !== 'https:') {
                        return false;
                    }
                    return true;
                } catch (error) {
                    return false;
                }
            }

            /**
             * @param {string} feedUrl
             * @returns {string}
             */
            function requestFeedXMLDocument(feedUrl) {
                const url = `http://localhost:8080/feed?feed=${encodeURIComponent(feedUrl)}`;
                return fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/xml',
                    },
                }).then(
                    response => response.text()
                ).catch((error) => {
                    const { message } = error;
                    console.log(message);
                });
            }

            // const feedUrls = [
            //     'https://www.marijuanamoment.net/feed/',
            //     'https://nysmusic.com/feed/',
            // ].forEach(feedUrl => {
            //     const channelElement = document.createElement('rss-feed-channel');
            //     channelElement.setAttribute('feed-url', feedUrl);
            //     const accordionWrapper = document.querySelector('.main-content__feed-accordion-wrapper');
            //     if (accordionWrapper) {
            //         accordionWrapper.appendChild(channelElement);
            //     }
            // });

            class RSSFeedItemAccordionElement extends HTMLElement {
                constructor() {
                    super();
                    const templateElement = document.querySelector('#rss-item-accordion-template');
                    const shadowRoot = this.attachShadow({ mode: 'open' });
                    shadowRoot.appendChild(templateElement.content.cloneNode(true));
                    this.handleToggleClick = this.handleToggleClick.bind(this);
                }

                handleToggleClick(mouseEvent) {
                    const articleDiv = this.shadowRoot.querySelector('article > div');
                    if (articleDiv) {
                        articleDiv.classList.toggle('expanded');
                    }
                }

                connectedCallback() {
                    const height = this.shadowRoot.querySelector('article > div')?.scrollHeight ?? 0;
                    if (height) {
                        const styleSheet = this.shadowRoot.styleSheets.item(0);
                        let hostRule = null;
                        for (let i = 0; i < styleSheet.cssRules.length; ++i) {
                            const rule = styleSheet.cssRules.item(0);
                            if (rule) {
                                if (rule.selectorText === ':host') {
                                    hostRule = rule;
                                    break;
                                }
                            }
                        }
                        if (hostRule) {
                            hostRule.style.setProperty('--expanded-height', `${height}px`);
                        }
                    }
                    const toggleButton = this.shadowRoot.querySelector('article button');
                    if (toggleButton) {
                        toggleButton.addEventListener('click', this.handleToggleClick);
                    }
                }

                disconnectCallback() {
                    const toggleButton = this.shadowRoot.querySelector('article button');
                    if (toggleButton) {
                        toggleButton.removeEventListener('click', this.handleToggleClick);
                    }
                }
            }

            class RSSFeedChannelElement extends HTMLElement {
                constructor() {
                    super();
                    const templateElement = document.querySelector('#rss-channel-template');
                    const shadowRoot = this.attachShadow({ mode: 'open' });
                    shadowRoot.appendChild(templateElement.content.cloneNode(true));
                }

                connectedCallback() {
                    const feedUrl = this.getAttribute('feed-url');
                    Application.getInstance().loadRSSFeed(feedUrl).then(channel => {
                        const renderedItems = channel.items.map(renderRSSAccordionItem);
                        const titleHeader = this.shadowRoot.querySelector('section > header > h1');
                        if (titleHeader) {
                            titleHeader.textContent = channel.title;
                        }
                        const descriptionHeader = this.shadowRoot.querySelector('section > header > h2');
                        if (descriptionHeader) {
                            descriptionHeader.textContent = channel.description;
                        }
                        this.append(...renderedItems);
                    }).catch(console.error);
                    // requestFeedXMLDocument(feedUrl).then(xmlText => {
                    //     const channel = new RSSFeedChannel(feedUrl, xmlText);
                    //     const renderedItems = channel.items.map(renderRSSAccordionItem);
                    //     const titleHeader = this.shadowRoot.querySelector('section > header > h1');
                    //     if (titleHeader) {
                    //         titleHeader.textContent = channel.title;
                    //     }
                    //     const descriptionHeader = this.shadowRoot.querySelector('section > header > h2');
                    //     if (descriptionHeader) {
                    //         descriptionHeader.textContent = channel.description;
                    //     }
                    //     this.append(...renderedItems);
                    // }).catch(console.error);
                }
            }
            
            class UserInputDialogElement extends HTMLElement {
                constructor() {
                    super();
                    const templateElement = document.querySelector('#user-input-dialog-template');
                    const shadowRoot = this.attachShadow({ mode: 'open' });
                    shadowRoot.appendChild(templateElement.content.cloneNode(true));
                }

                show() {
                    return new Promise((resolve, reject) => {
                        const dialogElement = this.shadowRoot.querySelector('dialog');
                        if (dialogElement) {
                            
                            dialogElement.addEventListener('transitionend', () => {
                                resolve(this);
                            }, {
                                once: true,
                            });

                            if (!dialogElement.classList.contains('visible')) {
                                dialogElement.classList.add('visible');
                            } else {
                                resolve(this);
                            }
                        } else {
                            reject(this);
                        }
                    });
                }

                hide() {
                    return new Promise((resolve, reject) => {
                        const dialogElement = this.shadowRoot.querySelector('dialog');
                        if (dialogElement) {

                            dialogElement.addEventListener('transitionend', () => {
                                resolve(this);
                            }, {
                                once: true,
                            });

                            if (dialogElement.classList.contains('visible')) {
                                dialogElement.classList.remove('visible');
                            } else {
                                resolve(this);
                            }
                        } else {
                            reject(this);
                        }
                    });                    
                }
            }

            class AddFeedURLDialogElement extends HTMLElement {
                constructor() {
                    super();
                    const templateElement = document.querySelector('#add-feed-url-dialog-template');
                    const shadowRoot = this.attachShadow({ mode: 'open' });
                    shadowRoot.appendChild(templateElement.content.cloneNode(true));
                    this.onURLInputChange = this.onURLInputChange.bind(this);
                    this.onCancelButtonClick = this.onCancelButtonClick.bind(this);
                    this.onAddButtonClick = this.onAddButtonClick.bind(this);
                }

                connectedCallback() {
                    const urlInputField = this.shadowRoot.querySelector('input[type="url"]');
                    const addButton = this.shadowRoot.querySelector('button.dialog-button__ok');
                    const cancelButton = this.shadowRoot.querySelector('button.dialog-button__cancel');
                    if (urlInputField) {
                        urlInputField.addEventListener('keyup', this.onURLInputChange);
                    }
                    if (addButton) {
                        addButton.addEventListener('click', this.onAddButtonClick);
                    }
                    if (cancelButton) {
                        cancelButton.addEventListener('click', this.onCancelButtonClick);
                    }
                }

                disconnectCallback() {
                    const urlInputField = this.shadowRoot.querySelector('input[type="url"]');
                    const addButton = this.shadowRoot.querySelector('button.dialog-button__ok');
                    const cancelButton = this.shadowRoot.querySelector('button.dialog-button__cancel');
                    if (urlInputField) {
                        urlInputField.removeEventListener('keyup', this.onURLInputChange);
                    }
                    if (addButton) {
                        addButton.removeEventListener('click', this.onAddButtonClick);
                    }
                    if (cancelButton) {
                        cancelButton.removeEventListener('click', this.onCancelButtonClick);
                    }
                }

                onURLInputChange(e) {
                    // Toggle the Add button's disabled state based on input field validity.
                    const { target : { validity : { valid = false } } } = e;
                    const isValid = e.target.checkValidity();
                    const addButton = this.shadowRoot.querySelector('button.dialog-button__ok');
                    if (addButton) {
                        if (isValid && addButton.hasAttribute('disabled')) {
                            addButton.removeAttribute('disabled');
                        } else if (!isValid && !addButton.hasAttribute('disabled')) {
                            addButton.setAttribute('disabled', '');
                        }
                    }
                }

                onCancelButtonClick(e) {
                    Application.getInstance().hideAddFeedURLDialog();
                }

                onAddButtonClick(e) {
                    const urlInputField = this.shadowRoot.querySelector('input[type="url"]');
                    const urlValue = urlInputField?.value ?? '';
                    if (urlInputField.validity.valid && isValidUrl(urlValue)) {
                        Application.getInstance()
                            .addRSSFeedUrlSubscription(urlValue)
                            .hideAddFeedURLDialog();
                    }
                }

                show() {
                    return new Promise((resolve, reject) => {
                        const userInputDialogElement = this.shadowRoot.querySelector('user-input-dialog');
                        if (userInputDialogElement) {
                            userInputDialogElement.show().then(() => resolve(this)).catch(() => reject(this));
                        } else {
                            reject(this);
                        }
                    });
                }

                hide() {
                    return new Promise((resolve, reject) => {
                        const userInputDialogElement = this.shadowRoot.querySelector('user-input-dialog');
                        if (userInputDialogElement) {
                            userInputDialogElement.hide().then(() => resolve(this)).catch(() => reject(this));
                        } else {
                            reject(this);
                        }
                    });
                }
            }

            window.customElements.define('rss-feed-item-accordion', RSSFeedItemAccordionElement);
            window.customElements.define('rss-feed-channel', RSSFeedChannelElement);
            window.customElements.define('user-input-dialog', UserInputDialogElement);
            window.customElements.define('add-feed-url-dialog', AddFeedURLDialogElement);
            function showUpdateNotification() {
                if (confirm('New version available. Update now?')) {
                    window.location.reload();
                }
            }

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js', {
                        scope: '/',
                    }).then(registration => {
                        console.log(`Service worker registered for the following scope: ${registration.scope}`);

                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                console.log(`Worker state: ${newWorker.state}`);
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    showUpdateNotification();
                                }
                            });
                        });
                    })
                })
            }

            document.addEventListener('DOMContentLoaded', () => {
                Application.getInstance().loadApplicationState().handleShowAddURLDialogButtonClick();
            });

            window.addEventListener('unload', () => {
                Application.getInstance().storeApplicationState();
            });
        </script>
    </body>
</html>